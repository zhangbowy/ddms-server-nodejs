"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const create_def_1 = require("./create_def");
const create_proto_1 = require("./create_proto");
const debug_1 = require("debug");
let Debug = debug_1.debug("jsonpb");
class parse_unit {
    constructor() {
        this.type = 'none';
        this.array = false;
        this.count = 0;
    }
}
var parser_unit_maps = {};
var un_parse_package = {};
function is_un_code(package_name, msg_name) {
    if (!un_parse_package[package_name])
        return false;
    if (un_parse_package[package_name][msg_name])
        return true;
    return false;
}
exports.is_un_code = is_un_code;
function get_unit(package_name, msg_name, create = false) {
    if (!parser_unit_maps.hasOwnProperty(package_name)) {
        parser_unit_maps[package_name] = {};
    }
    let package_map = parser_unit_maps[package_name];
    if (!package_map.hasOwnProperty(msg_name)) {
        if (!create)
            return null;
        package_map[msg_name] = new pb_parser_unit(package_name, msg_name);
    }
    return package_map[msg_name];
}
function del_unit(package_name, msg_name, reason) {
    if (!parser_unit_maps.hasOwnProperty(package_name)) {
        return;
    }
    delete parser_unit_maps[package_name][msg_name];
    if (reason) {
        if (!un_parse_package[package_name])
            un_parse_package[package_name] = {};
        un_parse_package[package_name][msg_name] = reason;
    }
}
function parse_msg(package_name, msg_name, obj) {
    if (is_un_code(package_name, msg_name))
        return;
    let t = get_unit(package_name, msg_name, true);
    try {
        if (t)
            t.save_parse(obj);
    }
    catch (e) {
        Debug(e);
        console.log(e);
        del_unit(package_name, msg_name, e);
    }
}
exports.parse_msg = parse_msg;
function create_pb(package_name, msg_name) {
    if (is_un_code(package_name, msg_name))
        return '';
    let t = get_unit(package_name, msg_name);
    if (t)
        return t.create_bp();
    return '';
}
exports.create_pb = create_pb;
class pb_parser_unit {
    constructor(package_name, msg_name) {
        this.package_name = "";
        this.msg_name = "";
        this.info_map = new create_def_1.TeMap();
        this.info_list_map = {};
        this.h_maps = new create_def_1.HashMap();
        this.genId = 0;
        this.msg_name = msg_name || ('msg_name' + (this.genId++));
        this.package_name = package_name;
    }
    save_parse(obj) {
        if (typeof obj == 'string') {
            obj = JSON.parse(obj);
        }
        this._parseList(obj, this.msg_name);
        this.convert_to_info_map();
    }
    _parseList(obj, name, array = false) {
        if (obj == null || obj == undefined) return;
        let s_obj_type = typeof obj;
        let b_obj_array = obj instanceof Array;
        if (b_obj_array) {
            if (array && b_obj_array) {
                throw new Error("出现了不支持的二维数组 " + name);
            }
            let r_info_name = this.info_map.get(name);
            if (r_info_name && !r_info_name.array) {
                throw new Error("出现了不同的数据类型 " + name + " " + r_info_name.type + " 变成了 Array");
            }
            for (let i = 0; i < obj.length; i++) {
                this._parseList(obj[i], name, true);
            }
            this.info_list_map[name] = 1;
        }
        else if (s_obj_type == 'object') {
            let r_info_name = this.info_map.get(name);
            if (r_info_name) {
                throw new Error("出现了不同的数据类型 " + name + " " + r_info_name.type + " 变成了 Object");
            }
            for (let key in obj) {
                this._parseList(obj[key], name + '.' + key);
            }
        }
        else if (obj != "") {
            let use_type = s_obj_type;
            if (s_obj_type == "number") {
                if (Math.floor(obj) == obj) {
                    if (obj > 2147483647 || obj < -2147483648) {
                        use_type = 'int64';
                    }
                    else {
                        use_type = 'int32';
                    }
                }
                else {
                    use_type = 'double';
                }
            }
            else if (s_obj_type == 'boolean') {
                use_type = 'bool';
            }
            let r_info_name = this.h_maps.get(name);
            if (r_info_name.length > 0 && this.info_list_map.hasOwnProperty(name)) {
                throw new Error("出现了不同的数据类型 " + name + " " + (this.info_list_map.hasOwnProperty(name) ? "object" : "array") + "变成了 " + s_obj_type);
            }
            let r_type_info = this.info_map.get(name);
            if (r_type_info) {
                if (r_type_info.type != use_type) {
                    switch (r_type_info.type) {
                        case 'double':
                            if (['int32', 'int64', 'double'].indexOf(use_type) == -1)
                                r_type_info.type = 'string';
                            break;
                        case 'int32':
                            if (['int64', 'double'].indexOf(use_type) != -1)
                                r_type_info.type = use_type;
                            else if (['int32', 'int64', 'double'].indexOf(use_type) == -1)
                                r_type_info.type = 'string';
                            break;
                        case 'int64':
                            if (['double'].indexOf(use_type) != -1)
                                r_type_info.type = use_type;
                            else if (['int32', 'int64', 'double'].indexOf(use_type) == -1)
                                r_type_info.type = 'string';
                            break;
                        default:
                            throw new Error("出现了不同的数据类型 " + name + " " + r_type_info.type + " 变成了 " + use_type);
                    }
                }
                r_type_info.count++;
            }
            else {
                this.info_map.set(name, { type: use_type, array: array, count: 1 });
            }
        }
    }
    convert_to_info_map() {
        let map_kes = this.info_map.keys;
        map_kes.sort(function (a, b) { return a > b ? -1 : 1; });
        for (let i = 0; i < map_kes.length; i++) {
            let r_key = map_kes[i];
            let r_type_info = this.info_map.get(r_key);
            let r_key_list = r_key.split('.');
            for (let _i = 1; _i < r_key_list.length; _i++) {
                let f_key = r_key_list.slice(0, _i).join('.');
                let h_list = this.h_maps.get(f_key);
                if (h_list.indexOf(r_key_list[_i]) == -1)
                    this.h_maps.add(f_key, r_key_list[_i]);
            }
        }
        let changeHash = new create_def_1.HashMap();
        for (let i = 0; i < this.info_map.keys.length; i++) {
            let key = this.info_map.keys[i];
            let key_list = key.split('.');
            let info = this.info_map.get(key);
            if (!info)
                continue;
            let c_info = {
                type: info.type,
                name: key_list.pop(),
                reauqred: false,
                repeated: info.array,
                default: ''
            };
            changeHash.add(key_list.join('.'), c_info);
        }
    }
    create_bp() {
        let changeHash = new create_def_1.HashMap();
        for (let i = 0; i < this.h_maps.keys.length; i++) {
            let pb_key = this.h_maps.keys[i];
            let r_infos = this.h_maps.get(pb_key);
            for (let _i = 0; _i < r_infos.length; _i++) {
                let use_key = pb_key + '.' + r_infos[_i];
                let r_simple_v = this.info_map.get(use_key);
                if (!r_simple_v) {
                    let isArray = this.info_list_map[use_key] ? true : false;
                    let c_info = {
                        type: use_key.replace(/\./g, '_'),
                        name: r_infos[_i],
                        reauqred: false,
                        repeated: isArray,
                        default: ''
                    };
                    changeHash.add(pb_key.replace(/\./g, '_'), c_info);
                }
                else {
                    let c_info = {
                        type: r_simple_v.type,
                        name: r_infos[_i],
                        reauqred: false,
                        repeated: r_simple_v.array,
                        default: ''
                    };
                    changeHash.add(pb_key.replace(/\./g, '_'), c_info);
                }
            }
        }
        let head = `\n`;
        for (let i = 0; i < changeHash.keys.length; i++) {
            head += create_proto_1.Creator.parse(changeHash.keys[i], changeHash.get(changeHash.keys[i])) + '\n';
        }
        return head;
    }
}
